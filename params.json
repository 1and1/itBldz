{"name":"Itbldz","tagline":"MyWebsite Build-Tools - The only build-tools you'll ever need","body":"# itBldz Build-Tools\r\n\r\n__The only build-tool you'll ever need__\r\n\r\nThe goal is to provide an easy to setup framework which allow every development team a \"closed for modification, open for extension\"-plattform for their own needs.\r\n\r\n## Usage\r\n\r\n### Setup\r\n\r\nInstall itBldz\r\n\r\n```shell\r\nnpm install itbldz\r\n```\r\n\r\ncreate your config\r\n\r\n```shell\r\necho '{ \"say-hi\" : { \"helloworld\" : { \"task\" : \"helloworld\", \"package\" : \"grunt-helloworld\", \"dummytarget\": {} } } }' > build.json\r\necho '{ }' > config.json\r\n```\r\n\r\nsetup the build with your config\r\n\r\n```shell\r\n./node_modules/itbldz/bpm setup\r\n```\r\n\r\nexecute\r\n\r\n```shell\r\n./node_modules/itbldz/build\r\n```\r\n\r\nin the shell / commandline\r\n\r\n### Options\r\n\r\nAll your arguments will be passed to grunt.\r\n\r\nExamples:\r\n\r\nVerbose output:\r\n> build --verbose\r\n\r\nRun only tests\r\n> build test\r\n\r\nRun only tests but verbose\r\n> build test --verbose\r\n\r\nGet all tasks with description\r\n> build --help\r\n\r\nGet configs for a specific target (see )\r\n\r\n### Configure for your use case\r\n\r\nTo include this project, all you have to do is to configure the build.json and\r\nthe config.json.\r\n\r\n#### build.json\r\n\r\n**What to do**\r\n\r\nThe build.json is the task-template. It orchestrates the build, and is separated\r\ninto build-steps, task-groups and tasks.\r\n\r\n##### build-steps\r\nThe build-step is the first layer. It defines the main tasks of the build. You\r\nshould use a natural language that fits your build-pipeline best.\r\nTypical steps would be:\r\n* _prepare_ - prepares the build-environment\r\n* _validate_ - validates the source for syntax, sematics and style conformance\r\n* _compile_ - compiles the source code\r\n* _test_ - runs unit and quality (i.e. coverage) tests\r\n* _create-deployable_ - creates a deployable package for your code\r\n* _publish_ - publishes your deployable package to your environment\r\n\r\n##### task-groups\r\nTask-groups are containers for other task-groups and tasks. They do not run\r\nby itself, but rather orchestrate the task-groups and tasks they contain.\r\nThey are used to organize build-steps, and should use a natural language that\r\ndescribe their use best.\r\nAn example would be:\r\n* validate\r\n * _syntax_ - syntax check of the language\r\n * _semantic_ - semantic check of the language\r\n\r\n##### tasks\r\nTasks are the hard and soul, and are basically runners for grunt-tasks. They can\r\nhave arbitrary names and should describe best what they do, not what grunt task\r\nthey are using.\r\nWhich grunt-task they run is specified by the properties _task_ and _package_.\r\nThe _task_ field specifies the name of the grunt-task that should be run, while\r\nthe _package_ field specifies which npm package is required to run the task.\r\n**Note**: itBldz will install all required packages automatically. There is no\r\naction required on your side.\r\nAn example for tasks would be:  \r\n* validate\r\n * syntax\r\n   * _js_[task=jshint;package=grunt-contrib-jshint]  \r\n   * _php_[task=phplint;package=grunt-phplint]  \r\n\r\nThe build.json is to be the same on every environment you run the build.\r\n\r\n#### config.json\r\n\r\n**Where to do it**\r\n\r\nThe config.json is describing the environment the build is running in. It is\r\nused to control the directories, file-patterns, or environmental specifics.\r\nYou can use all variables in the config.json in your build.json by typing\r\n\r\n> &lt;%= config.YOURKEY %&gt;\r\n\r\nAn example would be:\r\n\r\n```json\r\n    {\r\n      \"directories\" : {\r\n        \"sources\" : \"sources\",\r\n        \"output\" : \"target\"\r\n      },\r\n      \"filesets\" : {\r\n        \"php\" : [\"**/*.php\", \"!**/framework/**\"]\r\n      }\r\n    }\r\n\r\n```\r\nMake sure the configuration natively reflects the language on how you are\r\ntalking about your environment.\r\n\r\nFor different environments you might have different configurations. Split them\r\nand reference the correct config when starting the build.\r\n\r\n#### Environment\r\n\r\nIn your configuration and build you can access the environment variables of your host system as well.\r\n\r\nAdd the Statement\r\n\r\n> &lt;%= env.ENV_VARIABLE %&gt;\r\n\r\nand it will automatically be replaced.\r\n\r\n#### Create your configured build\r\nOnce your done configuring the build, call\r\n\r\n```shell\r\n./node_modules/itbldz/bpm setup\r\n```\r\n\r\non the folder and the build will be created automatically.\r\n\r\nIf you want to add an additional module not in the configuration (which you\r\ndon't want to do, you really want it all the configuration and not call manually,\r\nbut it's always nice to know you could) you can call\r\n\r\n```shell\r\n./node_modules/itbldz/bpm add --m buildstep/module --t Taskname --p some-grunt-package\r\n```\r\nAnd the module will be added automatically to the buildstep. Note that this will\r\nnot actually run the module as long as it is not configured in the build.json\r\n\r\n#### Adjust build for different environments\r\nOccasionally your environments are not the same from dev to live, and you want\r\nto adjust stuff. Most probably sensitive information you don't want to share\r\non github.com.\r\n\r\nTo achieve this, you can overwrite parts of the configuration (or the complete\r\nconfiguration) with target-files in the format \"config.[target].json\" by\r\npassing the following arguments to itbldz:\r\n\r\n* _target_ : string - The target to address\r\n* _target-path_ : string - The path to the target files. Defaults to current path\r\n* _target-overwrite_ (short: o) : boolean - If true, the leaf will be replaced by the target\r\n    (default false)\r\n\r\nExample:\r\n\r\n```json\r\n{\r\n    \"other\" : {},\r\n    \"database\": {\r\n        \"server\": \"localhost\",\r\n        \"port\": \"123\"\r\n    },\r\n    \"stuff\" : {}\r\n}\r\n```\r\n_config.json_\r\n\r\n```json\r\n{\r\n    \"database\": {\r\n        \"server\": \"dbserver.corp.contoso.com\",\r\n        \"port\": \"1433\",\r\n        \"user\" : \"web\",\r\n        \"password\" : \"<%= env.PASSWORD %>\"\r\n    }\r\n}\r\n```\r\n_config.live.json_\r\n\r\nwhen calling\r\n\r\n```shell\r\n./node_modules/itbldz/build --target=live\r\n```\r\n\r\nThe resulting config will look like:\r\n```json\r\n{\r\n    \"other\" : {},\r\n    \"database\": {\r\n        \"server\": \"dbserver.corp.contoso.com\",\r\n        \"port\": \"1433\",\r\n        \"user\" : \"web\",\r\n        \"password\" : \"<%= env.PASSWORD %>\"\r\n    },\r\n    \"stuff\" : {}\r\n}\r\n```\r\n\r\n**NOTE:** You can only override defined steps in the master, you cannot add additional steps. Why? Because your deployment should be the same over all environments.\r\n\r\n__But my deployment to dev & live is very VERY differnet!__ Then you will have to add both to the master, and then override and thus deleting it for every environment.\r\n\r\n## Deving\r\n\r\n### Guidelines\r\n\r\nYou are free to extend the project as you wish. Every new code has to include\r\nunit tests and result in a green build when building the build-tools executing\r\n\r\n```shell\r\n./node_modules/itbldz/build\r\n```\r\n\r\n### Working with the task engine\r\n\r\nThe build-tools are using a simple task engine which allow for task aliasing and\r\nautomatic dependency resolving in npm.\r\nUsing the task engine you can easily extend the core of the build-tools. The bpm\r\ntools are following the conventions by the task engine to prepare the build.\r\n\r\nA build config step should look like the following to get you started:\r\n\r\n```json\r\n{\r\n  \"build-step\" : {\r\n    \"task\" : {\r\n      \"task\" : \"clean\",\r\n      \"package\" : \"grunt-contrib-clean\",\r\n      \"options\": { \"force\": true },\r\n      \"target\": [ \".\" ]\r\n    }\r\n  }  \r\n}\r\n```\r\n\r\nWhen confronted with such a build-step, the folder structure expected by the\r\ntask engine is:\r\n\r\n```\r\n  build-tools\r\n  |_ .build\r\n    |_ build-step\r\n      |_ task\r\n        task.js\r\n      build-step.js\r\n    gruntfile.js\r\n  build.json\r\n  config.json\r\n```\r\n\r\nWhen opening the build-step.js file you see the following code:\r\n\r\n```js\r\nvar conf = requireRoot('conf'), path = require(\"path\");\r\nvar taskengine = requireRoot('taskengine');\r\n\r\nmodule.exports = function (grunt) {\r\n  var taskContext = taskengine.startup({\r\n    \"grunt\" : grunt,\r\n    \"buildStep\" : path.basename(__filename, \".js\"),\r\n    \"path\" : __dirname\r\n  });\r\n\r\n  taskengine.run(taskContext);\r\n};\r\n```\r\n\r\nThe build-step simply starts up the taskengine and registers itself. Then\r\nrunning the taskengine.\r\n\r\nNext open the task.js.\r\n\r\n```js\r\nvar conf = requireRoot('conf');\r\n\r\nvar taskengine = requireRoot('lib/taskengine/te');\r\n\r\nmodule.exports = function (grunt) {\r\n  taskengine = taskengine({\r\n    \"parent\" : \"build-step\",\r\n    \"options\" : {\r\n      \"task\" : \"clean\",\r\n      \"package\" : \"grunt-contrib-clean\"\r\n    }\r\n  });\r\n\r\n  taskengine.runSubtask(\"clean\",\r\n    \"Cleaning everything from a directory\",\r\n    grunt,\r\n    grunt.config(\"build\")[\"build-step\"].task);\r\n};\r\n```\r\n\r\nThe task itself is registering itself, referencing the parent build-step, and\r\nthen running the subtask.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}