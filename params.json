{"name":"Itbldz","tagline":"MyWebsite Build-Tools - The only build-tools you'll ever need","body":"# itBldz Build-Tools\r\n\r\n__The only build-tool you'll ever need__\r\n\r\nThe goal is to provide an easy to setup framework which allow every development team a \"closed for modification, open for extension\"-plattform for their own needs.\r\n\r\n## Usage\r\n\r\n### Setup\r\n\r\nInstall itBldz\r\n\r\n```shell\r\nnpm install itbldz\r\n```\r\n\r\nexecute\r\n\r\n```shell\r\nbuild\r\n```\r\n\r\nin the shell / commandline\r\n\r\n### Options\r\n\r\nAll your arguments will be passed to grunt.\r\n\r\nExamples:\r\n\r\nVerbose output:\r\n> build --verbose\r\n\r\nRun only tests\r\n> build test\r\n\r\nRun only tests but verbose\r\n> build test --verbose\r\n\r\nGet all tasks with description\r\n> build --help\r\n\r\n### Configure for your use case\r\n\r\nTo include this project, all you have to do is to configure the build.json and the config.json.\r\n\r\n#### build.json\r\n\r\nThe build.json is the task-template. It orchestrates the build, and has four main tasks with the following subtasks:\r\n\r\n```\r\n* prepare           - prepares the build-environment\r\n    * clean         - cleans a folder (default: grunt-contrib-clean)\r\n    * mkdir         - creates a new directory (default: grunt-mkdir)\r\n* validate          - validates the source for syntax, sematics and style conformance\r\n    * syntax        - syntax check of the language\r\n        * js        - (default: grunt-jsvalidate)\r\n    * semantic      - semantic check of the language\r\n        * js        - (default: grunt-contrib-jshint)\r\n* test              - runs unit and quality (i.e. coverage) tests\r\n    * unit\r\n        * js        -  runs unittests against js\r\n    * coverage\r\n        * js        - runs unittests and checks the unit test code coverage for js\r\n* create-deployable - creates a deployable for the code (i.e. minification, uglification...)\r\n    * copy          - copies files\r\n```\r\n\r\nThe build.json has to be the same on every environment you run the build.\r\n\r\n```json\r\n    {\r\n      \"prepare\": { },\r\n      \"validate\": {\r\n        \"syntax\": {\r\n          \"js\" : {}\r\n          /* ... */\r\n        },\r\n        \"sematic\": {\r\n          \"js\" : {}\r\n          /* ... */\r\n        }\r\n      },\r\n      \"test\": {\r\n        \"coverage\" : {\r\n          \"js\" : {}\r\n          /* ... */\r\n        },\r\n        \"quality\" : {}\r\n      },\r\n      \"create-deployable\": { }\r\n    }\r\n\r\n```\r\n\r\n#### Tasks\r\n\r\nFor  each step add the task name and package as follows:\r\n\r\n```json\r\n{\r\n  \"prepare\": { },\r\n  \"validate\": {\r\n    \"syntax\": {\r\n      \"js\" : {\r\n        \"task\"    : \"jshint\",\r\n        \"package\" : \"grunt-contrib-jshint\"\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nOptions can be added to the js - step accordingly.\r\n\r\n#### config.json\r\n\r\nThe config.json is describing the environment the build is running in. It is used to control the directories, file-patterns, or environmental specifics.\r\nYou can use all variables in the config.json in your build.json by typing\r\n\r\n> &lt;%= config.YOURKEY %&gt;\r\n\r\n```json\r\n    {\r\n      \"directories\" : {\r\n        \"sources\" : \"sources\",\r\n        \"output\" : \"target\"\r\n      },\r\n      \"filesets\" : {\r\n        \"php\" : [\"**/*.php\", \"!**/framework/**\"]\r\n      }\r\n      /* ... */\r\n    }\r\n\r\n```\r\n\r\n#### Create your configured build\r\nOnce your done configuring the build, call\r\n\r\n> bpm setup\r\n\r\non the folder and the build will be created automatically.\r\n\r\nIf you want to add an additional module not in the configuration (which you don't) you can call\r\n\r\n> bpm add --m buildstep/module --t Taskname --p some-grunt-package\r\n\r\nAnd the module will be added automatically to the buildstep.\r\n\r\n## Deving\r\n\r\n### Guidelines\r\n\r\nYou are free to extend the project as you wish. Every new code has to include\r\nunit tests and result in a green build when building the build-tools using the\r\ndefault build.json & config.json\r\n\r\n### Working with the task engine\r\n\r\nThe build-tools are using a simple task engine which allow for task aliasing and\r\nautomatic dependency resolving in npm.\r\nUsing the task engine you can easily (and with almost no code) extend the core\r\nof the build-tools.\r\n\r\nAll you have to do is follow some conventions.\r\n\r\nA build config step should look like the following to get you started:\r\n\r\n```json\r\n{\r\n  \"build-step\" : {\r\n    \"task\" : {\r\n      \"language-or-options\" : { },\r\n      \"other-language-or-more-options\" : { }\r\n    }\r\n  }  \r\n}\r\n```\r\n\r\nNow to setup your build-step, add a folder \"build-step\" to your .build folder,\r\nadd a build-step.js to the folder, and add a task-folder to the \"build-step\"\r\nfolder, again with a task.js file.\r\nYour directory might now look something like this:\r\n\r\n```\r\n  build-tools\r\n  |_ .build\r\n    |_ build-step\r\n      |_ task\r\n        task.js\r\n      build-step.js\r\n    gruntfile.js\r\n  build.json\r\n  config.json\r\n```\r\n\r\nopen the build-step.js file and open the following ceremony code:\r\n\r\n```js\r\nvar conf = requireRoot('conf'), path = require(\"path\");\r\nvar taskengine = requireRoot('taskengine');\r\n\r\nmodule.exports = function (grunt) {\r\n  var taskContext = taskengine.startup({\r\n    \"grunt\" : grunt,\r\n    \"buildStep\" : path.basename(__filename, \".js\"),\r\n    \"path\" : __dirname\r\n  });\r\n\r\n  taskengine.run(taskContext, 'Run my custom buildstep.');\r\n};\r\n```\r\n\r\nNext open the task.js. In order for it to do anything, we will use it to clean\r\na directory.\r\nAdd the following ceremony maccaroni:\r\n\r\n```js\r\nvar conf = requireRoot('conf');\r\n\r\nvar taskengine = requireRoot('lib/taskengine/te');\r\n\r\nmodule.exports = function (grunt) {\r\n  taskengine = taskengine({\r\n    \"parent\" : \"build-step\",\r\n    \"options\" : {\r\n      \"task\" : \"clean\",\r\n      \"package\" : \"grunt-contrib-clean\"\r\n    }\r\n  });\r\n\r\n  taskengine.runSubtask(\"clean\",\r\n    \"Cleaning everything from a directory\",\r\n    grunt,\r\n    grunt.config(\"build\")[\"build-step\"].task);\r\n};\r\n```\r\n\r\nThe parent is our build-step defined above, our default task is clean using the\r\ngrunt-contrib-clean package.\r\n\r\nNow to register the build-step, open the build.json and paste the following:\r\n\r\n```json\r\n{\r\n  \"build-step\" : {\r\n    \"task\" : {\r\n      \"options\": { \"force\": true },\r\n      \"target\": [ \".\" ]\r\n    }\r\n  }  \r\n}\r\n```\r\n\r\nOpen the console and type\r\n\r\n> build\r\n\r\nCongratulations! You have just created a self deleting build.\r\nAll your just written files where deleted automatically! Brave new world :)\r\n\r\n#### Running tasks for multiple languages\r\n\r\nConsider you want your task.js to trigger different tasks for different\r\nlanguages.\r\nStart of by modifying your config to look like the following:\r\n\r\n```json\r\n{\r\n  \"build-step\" : {\r\n    \"task\" : {\r\n      \"js\" : {\r\n        \"options\": { \"force\": true },\r\n        \"target\": [ \"js\" ]\r\n      },\r\n      \"css\" : {\r\n        \"options\": { \"force\": true },\r\n        \"target\": [ \"css\" ]\r\n      }\r\n    }\r\n  }  \r\n}\r\n```\r\n\r\nand in your task.js file change the options to an array with the two values\r\n\"task->js\" and \"task->css\" and add an additional line where you call the\r\n\"loadTaskDirectories\" function of the taskengine.\r\n\r\n```js\r\nvar conf = requireRoot('conf');\r\n\r\nvar taskengine = requireRoot('lib/taskengine/te');\r\n\r\nmodule.exports = function (grunt) {\r\n  taskengine = taskengine({\r\n    \"parent\" : \"build-step\",\r\n    \"options\" : {\r\n      \"task\" : [\"task->js\", \"task->css\"],\r\n      \"package\" : \"grunt-contrib-clean\"\r\n    }\r\n  });\r\n\r\n  taskengine.loadTaskDirectories(grunt, __dirname, \"build-step/task\");\r\n  taskengine.runSubtask(\"clean\",\r\n    \"Cleaning everything from a directory\",\r\n    grunt,\r\n    grunt.config(\"build\")[\"build-step\"].task);\r\n};\r\n```\r\n\r\nAdd two folders \"js\" and \"css\" to the directory, and place two files inside. The\r\nfiles now act as leafed subtask and look like task.js did before. For instance,\r\nthe file in the js folder would look like this:\r\n\r\n```js\r\nvar te = requireRoot('lib/taskengine/te');\r\n\r\nmodule.exports = function (grunt) {\r\n  te = new te({\r\n    \"parent\" : \"task\",\r\n    \"options\" : {\r\n      \"task\" : \"clean\"\r\n    }\r\n  });\r\n\r\n  te.runSubtask(\"js\", \"Cleaning up the js files\",\r\n    grunt,\r\n    grunt.config(\"build\")[\"build-step\"].task.js);\r\n};\r\n\r\n```\r\n\r\nYou can add as much layers as you like.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}